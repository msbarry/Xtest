runWhileEditing: false
runOnSave: true
import static org.^xtest.test.TestUtils.*
import static org.junit.Assert.*
import org.^xtest.Xtest

// Utility methods

def static assertFailsTo(String input, String... expectedMessage) {
	assertValidSyntax(input)
	val result = Xtest::run(input, injector)
	assertEquals("number of exceptions", 1, result.evaluationException.size)
	val compiledExpected = expectedMessage.fold("", [prev,next|prev+next+"\n"])
	assertEquals(compiledExpected.trim, result.evaluationException.head.cause.message.trim)
}
def static preamble {"Assertion failed"}
def static value(String expr, Object actual) {
	if (actual==null) "   \""+expr+"\" was: null"
	else "   \""+expr+"\" was: "+actual+" ("+actual.getClass.simpleName+")"
}
def static skipped(String expr) {"   \""+expr+"\" was: skipped"}
def static messageForNoException(Class<? extends Exception> e) {
	"Expected <"+e.getName+"> but no exception was thrown"
}
def static messageForWrongException(Class<?> expected, Class<?> actual) {
	"Expected <"+expected.getName+"> but threw <"+actual.getName+"> instead"
}

// Tests

xtest "exceptions" {	
	xtest {
		assertFailsTo("assert null throws IllegalArgumentException", 
			messageForNoException(IllegalArgumentException::class)
		)
	}
	
	xtest {
		assertFailsTo("assert 1/0 throws IllegalArgumentException", 
			messageForWrongException(IllegalArgumentException::class, ArithmeticException::class)
		)
	}
}

xtest "simple equals" {
	assertFailsTo(
		"assert 1 == 2",
		preamble,
		value("1 == 2", false)
	)
}

xtest "enclosed in parenthesis" {
	assertFailsTo(
		"assert ((1 == 2))",
		preamble,
		value("1 == 2", false)
	)
}

xtest "not operator" {
	assertFailsTo(
		"assert !(1 == 1)",
		preamble,
		value("!(1 == 1)", false),
		value("1 == 1", true)
	)
}

xtest "resolves variables" {
	assertFailsTo(
		"val a = 1; val b = 2; assert a == b",
		preamble,
		value("a == b", false),
		value("a", 1),
		value("b", 2)
	)
}

xtest "or operator" {
	assertFailsTo(
		"assert 1 == 2 || 2 == 3",
		preamble,
		value("1 == 2 || 2 == 3", false),
		value("1 == 2", false),
		value("2 == 3", false)
	)
}

xtest "short circuit and operator" {
	assertFailsTo(
		"assert 1 == 2 && 2 == 3",
		preamble,
		value("1 == 2 && 2 == 3", false),
		value("1 == 2", false),
		skipped("2 == 3")
	)
}

xtest "line break" {
	assertFailsTo(
		"assert 1\n==\n2",
		preamble,
		value("1 == 2", false)
	)
}

xtest "block expression" {
	assertFailsTo(
		"assert {1 == 2}",
		preamble,
		value("1 == 2", false)
	)
}

xtest "if expression" {
	assertFailsTo(
		"assert {if (true) false else true}",
		preamble,
		value("if (true) false else true", false)
	)
}

xtest "closure skipped" {
	assertFailsTo(
		"assert newArrayList(true).map[!it].head",
		preamble,
		value("newArrayList(true).map[!it].head", false),
		value("newArrayList(true).map[!it]", newArrayList(true).map[!it]),
		value("newArrayList(true)", newArrayList(true))
	)
}

xtest "handles null" {
	assertFailsTo(
		"assert if (true) null else null",
		preamble,
		value("if (true) null else null", null)
	)
}

xtest "handles string" {
	assertFailsTo(
		'val Object a = "s"; assert switch (a) {String: a == "z"\nInteger: a == 1}',
		preamble,
		value('switch (a) {String: a == "z" Integer: a == 1}', false),
		value('a', '"s"'),
		value('a == "z"', false),
		value('a', '"s"')
	)
}

xtest "ignores for" {
	assertFailsTo(
		'assert for (i : 1..10) println(i)',
		preamble,
		value('for (i : 1..10) println(i)', null)
	)
}