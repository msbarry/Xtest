runWhileEditing: false
runOnSave: true

import org.^xtest.XTestRunner

import static org.junit.Assert.*
import static org.^xtest.test.XTestRunnerUnitTests.*
import static extension org.^xtest.test.TestUtils.*
import static org.hamcrest.CoreMatchers.*
 
xtest "top-level assert" {
    val result = XTestRunner::run('assert false', injector);
    val exception = result.evaluationException.head
    val stackTrace = exception.getCause.getStackTrace
    assertEquals(1, stackTrace.size)
    stackTrace.head.assertXtestStackTrace("assert false", 1)
}

xtest "top-level exception, second line" {
    val result = XTestRunner::run('
1/0', injector);
    val exception = result.evaluationException.head
    val stackTrace = exception.getCause.getStackTrace
    assertEquals(1, stackTrace.size)
    stackTrace.head.assertXtestStackTrace("1/0", 2)
}

xtest "assert in inline closure" { 
    val result = XTestRunner::run('[|assert false].apply', injector);
    val exception = result.evaluationException.head
    val stackTrace = exception.getCause.getStackTrace
    assertEquals(3, stackTrace.size)
    ?stackTrace.get(0).assertXtestStackTrace("assert false", 1)
    ?stackTrace.get(1).assertProxyStackTrace
    ?stackTrace.get(2).assertXtestStackTrace("[|assert false].apply", 1)
}

xtest "nested exception in inline closure" { 
    val result = XTestRunner::run('{{{[|{{1/0}}].apply}}}', injector);
    val exception = result.evaluationException.head
    val stackTrace = exception.getCause.getStackTrace
    assertEquals(3, stackTrace.size)
    ?stackTrace.get(0).assertXtestStackTrace("1/0", 1)
    ?stackTrace.get(1).assertProxyStackTrace
    ?stackTrace.get(2).assertXtestStackTrace("[|{{1/0}}].apply", 1)
}