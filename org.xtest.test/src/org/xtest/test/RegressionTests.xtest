/* File-specific parameters */
runWhileEditing: false
// TODO - when Guice fixes memory leak, re-enable running on save
// (http://code.google.com/p/google-guice/issues/detail?id=288)
runOnSave: false
import helpers.SUT
import org.^xtest.Xtest

import static org.junit.Assert.*
import static org.^xtest.test.TestUtils.*

xtest testBug1 {
    val result = Xtest::parse('
xsuite test {
	xtest case {
		assert 1 == 1 
		assert 2 ==
		assert 3 == 3
	}
}', injector)
    typeProvider.getCommonReturnType(result, true) 
} 
xtest testBug2 {
    val result = Xtest::parse('
val a = new java.util.TreeMap
xtest test {
	assert a.descendingMap == a
}', injector)
    typeProvider.getCommonReturnType(result, true)
}

xtest bug3 {
	val result = Xtest::parse('	
import java.util.List
xtest mockito {
	val mo   List::class.mock
}', injector)
    runValidation(result)
}

xtest testCodeNotRun {
    val parse = parse('
val a = 1
if (a == 1) true else false
')
    val warningsRunTests = getWarningsRunTests(parse)
    assertEquals(1, warningsRunTests.size())
}
 
xtest testFirstImport {
    val parse = parse('
import java.util.ArrayList
import java.util.LinkedHashMap
val a = new ArrayList<String>')
    assertValidationPassed(parse)
}

xtest testCodeNotRunOnly1Warning {
    val parse = parse('
val a = 1
if (a == 1) true else {if (a != 1) true else false}')
    val warningsRunTests = getWarningsRunTests(parse)
    assertEquals(1, warningsRunTests.size())
}

xtest testCodeNotRunParamFalse {
    val parse = parse('
markUnexecuted: false
val a = 1
if (a == 1) true else {if (a != 1) true else false}')
    val warningsRunTests = getWarningsRunTests(parse)
    assertEquals(0, warningsRunTests.size())
}

xtest testCodeNotRunParamTrue {
    val parse = parse('
markUnexecuted: true
val a = 1
if (a == 1) true else {if (a != 1) true else false}')
    val warningsRunTests = getWarningsRunTests(parse)
    assertEquals(1, warningsRunTests.size())
}

 
xtest testGetClass {
    val parse = parse('System::class')
    assertValidationPassed(parse)
    assertEvaluatesTo(System::class, parse)
    val typeForName = typeRefs.getTypeForName(Class::class, parse,
            typeRefs.getTypeForName(System::class, parse))
    assertReturnType(typeForName, parse)
}


xtest testGetClassImported {
    val parse = parse('import helpers.SUT; SUT::class')
    assertValidationPassed(parse)
    assertEvaluatesTo(SUT::class, parse)
    val typeForName = typeRefs.getTypeForName(Class::class, parse,
            typeRefs.getTypeForName(SUT::class, parse))
    assertReturnType(typeForName, parse)
}


xtest testGetClassNotImported {
    val parse = parse('helpers::SUT::class')
    assertValidationPassed(parse)
    assertEvaluatesTo(SUT::class, parse)
    val typeForName = typeRefs.getTypeForName(Class::class, parse,
            typeRefs.getTypeForName(SUT::class, parse))
    assertReturnType(typeForName, parse)
}


xtest testGetPrivateSubMember {
    val parse = parse('
import helpers.SubPrivateMembers
val a = new SubPrivateMembers()
a.i')
    assertValidationPassed(parse)
    assertEvaluatesTo(1, parse)
}


xtest testGetPrivateSubMethod {
    val parse = parse('
import helpers.SubPrivateMembers
val a = new SubPrivateMembers()
a.setC(2)
a.i')
    assertValidationPassed(parse)
    assertEvaluatesTo(2, parse)
}


xtest testGetPrivateSuperMember {
    val parse = parse('
import helpers.*
val a = new SubPrivateMembers()
(a as PrivateMembers).i')
    assertValidationPassed(parse)
    assertEvaluatesTo(0, parse)
}


xtest testGetPrivateSuperMethod {
    val parse = parse('
import helpers.*
val a = new SubPrivateMembers()
(a as PrivateMembers).setC(2)
a.getC()')
    assertValidationPassed(parse)
    assertEvaluatesTo(1, parse)
}


xtest exceptionInClosure {
    val parse = parse('
val a = [String s|throw new Exception]
a.apply("c")')
    assertValidationPassed(parse)
}


xtest testBug1 {
    val result = Xtest::parse('
assert 1 == 1', injector)
    assertEquals("Boolean", typeProvider.getCommonReturnType(result, true).simpleName) 
} 

xtest safeTypeComputation {
	val parse = parse('val a = ?assert 1 == \n?assert 1 == 2')
	runValidation(parse)
}

xtest "exception was thrown" {
	val script=
'def static 

def <T> get(T i) {
	def get2(T j) {
		j
	}
	get2(i)
}  

get(1)'
    val body = parse(script)
    runValidation(body)
    typeProvider.getCommonReturnType(body, true)
}
xtest "bug" {
	assertTestPasses("assert 1 == 1; println(1)") 
	assertTestPasses("assert 1/0 throws Exception; println(1)") 
}